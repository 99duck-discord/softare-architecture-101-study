# 모듈성
## 🔎 Survey and Question - 훑어보고 질문하기

### 3 모듈성
* 소프트웨어 아키텍처에서 말하는 모듈성이란 무엇이며 어떻게 측정되는지 주로 다룰 것 같다.
* Q. 모듈성을 둘러싸고 있는 아키텍처 논쟁이란?
* A. 모듈성과 관련하여 수십가지의 정의가 난무하지만, 전혀 일관성이 없고 모순된 정의조차 존재한다.

#### 3.1 정의
* 큰 틀에서 말하는 모듈성이란 무엇인지 설명한느 챕터인듯 하다
* Q. 소프트웨어 아키텍처에서 말하는 모듈이란?
* A. 개발자에게 있어 클래스, 함수와 같은 코드들을 묶어놓은 덩어리인 논리적인 모듈성과 자바에서의 패키지와 같은 물리적인 모듈성을 얘기하는 듯 하며, 이들을 재사용성이 용이하도록 만들어 둔 것을 모듈이라고 말하는 것 같다
* Q. 클래스(객체지향) 이전에는 어떤 방식으로 모듈을 재활용했으며, 어떤 단점이 있었는가?
* A. 객체지향 이전에는 goto문법과 모듈러(modular)언어를 사용하였는데, goto문법 같은 경우에는 비선형적인 흐름이 잦아 로직을 이해하고 디버깅 하는데 문제가 많았으며, 모듈러 언어 같은 경우, 향후 객체지향 언어들이 출현하고 쇠퇴하였지만, 객체지향에서도 채택한 모듈-패키지나 네임스페이스로 알려진-이란 개념을 정립하였다

#### 3.2 모듈성 측정
* 모듈성을 측정하는 방법을 세가지 메트릭인 응집, 커플링, 커네이선스를 통하여 설명해줄 듯 하다
* Q. 응집이란 무엇인가?
* A. 한 모듈의 구성요소가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타내는 것
* Q. 커플링이란 무엇인가?
* A.
* Q. 커네이선스란 무엇인가?
* A. 

#### 3.3 모듈에서 컴퍼넌트로
* 모듈과 컴퍼넌트가 어떻게 다른지 간략하게 설명하는 내용같다

## 📝 Read & Recite - 읽어보고 노트하기

### 3 모듈성
> 소프트웨어 아키텍처 용어의 95%는 '모듈성'의 이로움을 찬양하는데 사용되고 있지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별다른 얘기가 없다.
> - 글렌포드 J. 마이어스
* 모듈성은 정의를 내리기가 쉽지 않다
  * 수십가지 정의가 난무하나, 전혀 일관성이 없고, 모순된 정의조차 존재한다
* 모듈성은 일종의 구성원리*organization principle*이다.
  * 우리가 아키텍처를 분석해야 할(메트릭, 피트니스 함수, 시각화 등) 많은 도구가 모듈성에 의존한다
* 모듈성은 암묵적인 아키텍처 특성이다
  * 아무도 모듈이 확실히 구분되고 모듈간 통신이 잘 되어야 한다고 아키텍트에게 요구하지는 않는다. 그러나 코드베이스를 잘 발전시켜 나가려면 암묵적으로 질서와 일관성이 필요하다

#### 3.1 정의
* 모듈성의 사전적 정의
  * -> 복잡한 구조를 만드는데 쓰이는 각각의 표준화한 부품이나 독립적인 단위
* 소프트웨어 아키텍처에 있어 개발자가 프로젝트를 어떻게 패키징 하는지 아는 것은 중요하다.
  * 여러 패키지가 단단하게 엮여 있다면 그 중 하나를 다른 작업에 재사용하기가 매우 어렵다.
  * `논리적인 모듈성`
    * 클래스, 함수처럼 코드를 묶어놓은 덩어리
  * `물리적인 모듈성`
    * 자바 패키지 구조처럼 물리적인 디렉터리 구조
  * 모르는 단어가 튀어나옴 : [메타 오브젝트 프로토콜](https://en.wikipedia.org/wiki/Metaobject)
* 클래스(객체지향) 이전의 모듈 재사용
  * `GOTO 문법`
    * 비선형적인 흐름이 잦아 로직을 이해하고 디버깅하는데 문제가 많았다
  * `모듈러 언어`
    * Pascal의 창시자 니클라우스 비르트가 창시한 언어이다
    * Modula 또는 Ada 같은, 모듈-패키지나 네임스페이스 따위의-이란 프로그래밍 요소를 가진 언어이다
  * 오래가지 못해 코드를 캡슐화하는 새로운 방식인 객체지향언어가 탄생하였으며, 객체지향언어에서도 모듈의 개념은 존속하였다.

#### 3.2 모듈성 측정
##### 3.2.1 응집
* 응집이란?
  * 한 모듈의 구성요소(part)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다
    * 모듈을 구성하는 파트가 얼마나 연고나되어 있는가?
  * 모든 파트가 함께 패키징 되어 있다면 이상적으로 응집된 모듈이다
    * 파트를 더 잘게 쪼개려면 모듈간 호출을 통해 파트를 묶어야 한다

> 응집된 모듈을 나누려고 해봤자 더 커플링되고 가독성은 떨어진다 - 래리 콘스탄틴

* 응집도의 측정범위 (가장 좋은 것부터 나쁜 순)
1. 기능성 응집 *functional cohesion*
   * 모듈의 각 파트는 다른 파트와 연관되어 있다
   * 기능상 꼭 필요한 모든 것이 모듈에 존재한다
2. 순차적 응집 *sequential cohesion*
   * 두 모듈에서 한쪽이 데이터를 출력하면 다른 한쪽이 입력받는 형태
3. 소통적 응집 *communicaion cohesion*
   * 두 모듈이 각자 정보에 따라 작동하거나, 어떤 출력을 내는 형태로 통신체인(communication chain)을 형성한다
4. 절차적 응집 *procedural cohesion*
   * 두 모듈은 정해진 순서대로 실행
5. 일시적 응집 *temporal cohesion*
   * 모듈은 시점 의존성에 따라 연관
     * 예) 시스템 초기에 시스템에서 관련 없는 것들을 초기화
6. 논리적 응집 *logical cohesion*
   * 모듈의 내부 데이터는 기능적이 아닌 논리적으로 연관
     * 텍스트, 직렬화 객체, 스트링 형태로 받은 데이터를 변환하는 모듈이 예이다(Java의 StringUtil 따위의)
7. 동시적 응집 *coincidential cohesion*
   * 같은 소스파일 내에 모듈 구성요소가 있지만 그 외에는 아무 연관이 없음

* 응집은 커플링보다는 덜 정확한 메트릭이기 때문에 아키텍트의 재량에 따라 측정된 응집도는 다르다

* 카이댐버와 케메러의 객체지향 메트릭 스위트
  * 응집성의 주관성을 전제로 응집도(응집의 결여도)를 가늠할 수 있는 구조적 메트릭 세트

1. 메서드의 응집 결여도 - LCOM
   * Lack of Cohesion in Method
   * LCOM v1과 LCOM96b라는 공식이 있으며, 기본적으로 공유필드를 통해 공유되지 않는 메서드의 총 갯수를 뜻한다.
     * LCOM 점수가 낮을 수록 응집도가 높다는 뜻이다

##### 3.2.2 커플링
* 메서드의 호출과 반환은 호출그래프를 그리므로 수학적인 분석이 간으하다.
* ***Structured Design**, 1979 에드워드 요던, 래리 콘스탄틴*
  * 커플링의 두가지 유형
    * 구심 커플링: 컴포넌트, 클래스 함수 등의 코드 아티팩트로 **유입**되는 접속 수
    * 원심 커플링: 컴포넌트, 클래스, 함수 등의 다른 코드 아티팩트로 **유출**되는 접속 수
  * 어느 플랫폼이든 코드베이스를 재구성, 마이그레이션, 분석할 때 도움을 주는 커플링 분석도구는 있다

##### 3.2.3 추상도, 불안정도, 메인 시퀀스로부터의 거리
* 추상도
  * *로버트 마틴*이 저술한 `C++`책에서 처음 사용
  * 추상 아티팩트와 구상 아티팩트(구현체)의 비율 -> *구현대비 추상화 정도*
    * 추상화를 전혀 하지 않았다는 것 => main()에 모든 코드가 들어있다는 것
    * 지나친 추상화 => 특정 코드가 어떤 일을 하는지 파악하기 한나절이 걸린다
  * 추상도는 추상클래스가 많을수록 증가한다 : 구현체가 많을수록 추상도는 감소한다
  * 아키텍트는 추상 아티팩트의 총 갯수와 구상 아티팩트의 총 갯수로 추상도를 계산한다
* 불안정도
  * 원심 커플링-*유출되는 커플링*- 대비 (구심 커플링 + 원심 커플링)의 비율로 파생된다. (커플링이 높다는 의미)
  * 불안정도는 코드베이스의 변동성을 의미한다
    * 변경시 커플링이 높아 깨지기 쉽다.
      * 여러 다른 클래스를 호출하여 작업을 위임하는 클래스는 호출되는 메서드 중 하나라도 변경된다면 호출하는 클래스 역시 잘못될 공산이 있다.

##### 3.2.4 메인 시퀀스부터의 거리 *Distance from the main sequence*
* 아키텍처 구조를 평가하는 몇가지 전체적인 메트릭 중 하나
* 불안정도와 추상도를 사용하여 계산한다
* 메인 시퀀스로부터의 거리는 추상도와 불안정도 사이의 이상적인 관계를 나타낸다
  * 메인 시퀀스로부터 *거리가 가까울 수록 균형이 맞으며*, 위로 올라갈수록 *과도한 추상화*를, 아래로 내려갈수록 *불안정도가 높아*져 취약하고 관리하기 힘든 코드가 된다.
* *웬만한 플랫폼에는 이런 메트릭을 측정하는 도구들이 있으므로 생소함, 마이그레이션, 기술부채 평가 등 분석에 이용한다*

##### 3.2.5 커네이션스 *connascence*
* ***What Every Programmer Should Know About Object Oriented Programming**, 1996 밀러페이지-존스*
  * 구심/원심 커플링 개념을 더욱 발전시킨 커네이선스 개념을 화두로 던졌다
  * *두 컴포넌트 중 한쪽이 변경된 경우 다른쪽도 변경해야 전체 시시템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다 - 밀러 페이지-존스*
* 커네이선스의 유형
  * 정적 커네이선스: 코드레벨의 커플링
    1. 명칭 커네이선스 *CoN*
      * 여러 컴포넌트의 엔터티(메서드)명이 일치한다
      * 가장 일반적이며 바람직한 방법
    2. 타입 커네이선스 *CoT*
       * 여러 컴포넌트의 엔터티 타입이 일치해야 한다
       * 정적타입 언어에서 매개변수 또는 변수를 특정 타입으로 지정하는 것
    3. 의미/관례 커네이선스 *CoM/CoC*
       * 여러 컴포넌트 간의 특정 값이 일치해야 한다
       * 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견된다 -> `int True = 1; int False = 0`
    4. 위치 커네이선스 *CoP*
       * 여러 컴포넌트는 값의 순서가 일치해야한다
       * 매개변수 타입이 동일하더라도 의미가 일치해야 한다
        ```java
          void updateSeat(String name, String seatLoc); //일 때
          updateSeat("14D", "Ford, N"); //이라면 매개변수의 타입은 맞지만 의미가 맞지 않게 된다
         ```
    5. 알고리즘 커네이선스 *CoA*
       * 여러 컴포넌트는 특정 알고리즘이 일치해야 한다.
       * 서버와 클라이언트 두 곳에서 모두 실행이 되는 해시 알고리즘의 경우 두 알고리즘이 맞지 않는다면 값의 전달이 정상적으로 이루어지지 않을 것
  * 동적 커네이선스: 런타임 호출을 분석
    1. 실행 커네이선스 *CoE*
       * 여러 컴포넌트의 실행순서가 중요하다. (p82. 예제를 참고)
    2. 시점 커네이선스 *CoT*
       * 여러 컴포넌트의 실행 시점이 중요하다
       * 동시에 실행중인 두 쓰레드 때문에 경합조건이 발생하여 공동의 작업에 영향을 끼칠 수 있다
    3. 값 커네이선스 *CoV*
       * 상호 연관된 값들을 함께 변경할 때 발생한다
       * 사각형을 예로 들어, 네 꼭지점 중 한 개의 꼭지점만 변경할 수 없다
    4. 식별 커네이선스 *CoI*
       * 어러 컴포넌트가 동일한 엔터티를 참조할 때 발생한다
       * 독립적인 컴포넌트들이 분산 큐 같은 자료구조를 공유해서 업데이트 하는식
    * *런타임 호출은 효과적인 분석도구가 많지 않아 동적 커네이선스를 파악하기 쉽지 않다*
  * 커네이선스 속성
    1. 강도
      * 커네이선스를 얼마나 쉽게 리팩토링 할 수 있는가?
        * 커네이선스 리팩토링 방향: `동적 커네이선스 -> 정적 커네이선스` -*다음과 같이 리팩토링한다*
          1. 아이덴티티
          2. 값
          3. 타이밍
          4. 실행
          5. 위치
          6. 알고리즘
          7. 의미
          8. 타입
          9. 명칭
    2. 지역성
      * 코드베이스의 모듈들이 얼마나 가까이 있는가?
      * 근접한 코드는 분리된 코드보다 높은 커네이선스를 가진다
      * 모듈을 떨어트렸을 때 커플링이 형편없어진다면 모듈을 서로 가까이 붙혀라
    3. 정도
      * 커네이선스가 미치는 영향의 규모
      * **작을 수록** 코드베이스에 바람직하다
      * 시스템의 모듈성을 개선하는 세 가지 방법
        1. 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화
        2. 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화
        3. 캡슐화 경계 내부에서 커네이선스를 최대화
      * *짐 웨이리치*(전설적인 소프트웨어 아키텍처 혁신가)가 남긴 두가지 조언
        1. *정도의 규칙* - 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
        2. *지역성의 규칙* - 소프트웨어 엘리먼트 간 거리가 멀어질수록 보다 약한형태의 커네이선스를 사용하라

## 😎 Review - 요약하기
